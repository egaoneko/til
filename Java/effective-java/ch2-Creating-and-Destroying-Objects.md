# 2장. 객체의 생성과 삭제

객체를 만들어야 하는 시점과 그 방법, 객체 생성을 피해야 하는 경우와 그 방법, 적절한 순간에 객체가 삭제되도록 보장하는 방법, 그리고 삭제 전에 반드시 이루어져야 하는 청소 작업들을 관리하는 방법을 살펴본다.

## 규칙 1. 생성자 대신 정적 팩터리 메서드를 사용할 수 없는지 생각해 보라

### 장점

* 생성자와는 달리 정적 팩터리 메서드에는 이름이 있다.
	* 이름을 잘 짓는다면 사용하기 쉽고, 클라이언트 코드의 가독성도 높아진다.
	* 시그너처별로 하나의 생성자만 넣을 수 있는 제약을 피할 수 있다.
* 생성자와는 달리 호출할 때마다 새로운 객체를 생성할 필요는 없다.
	* 변경 불가능 클래스라면 미리 만들어 둔 객체를 활용할 수 있다.
	* 만든 객체를 캐시 해놓고 재사용할 수 있다.
	* 객체 통제 클래스 : 어떤 시점에 어떤 객체가 얼마나 존재할지를 정밀하게 제어할 수 있는 클래스
* 생성자와는 달리 반환값 자료형의 하위 자료형 객체를 반환할 수 있다.
	* 반환되는 객체의 클래스를 유연하게 결정할 수 있다.
	* 인터페이스 기반 프레임워크 : ``public`` 으로 선언되지 않은 클래스의 객체를 반환하는 API를 만들 수 있으며 구현 세부사항을 감출 수 있으므로 간결한 API가 가능하다.
	* ex) ``java.util.Collections``
	* 클라이언트 코드는 반환된 객체의 실제 구현 세부사항이 아니라 인터페이스만 보고 작성하게 되는데, 일반적으로 바람직한 습관이다.
* 형인자 자료형 객체를 만들 때 편하다.
	* 자료형 유추 : 컴파일러가 형인자를 스스로 알아내도록 할 수 있다.
	* 형인자 유틸리티 클래스 안에 정정 팩터리 메서드 (1.7이상 부터 지원)

### 단점

* ``public`` 이나 ``protected`` 로 선언된 생성자가 없으므로 하위 클래스를 만들 수 없다.
	* 계승 대신 구성 기법을 쓰면 해결할 수 있다.
* 정적 팩터리 메서드가 다른 정적 메서드와 확연히 구분되지 않는다.
	* 정적 팩터리 메서드의 이름 : valueOf, of, getInstance, newInstance, getType, newType

### 요약

정적 팩터리 메서드와 public 생성자는 용도가 서로 다르며, 그 차이와 장단점을 이해하는 것이 중요하다. 정적 팩터리메서드가 효과적인 경우가 많으니, 정적 팩터리 메서드를 고려해 보지도 않고 무조건 public 생성자를 만드는 것은 삼가기 바란다.

## 규칙 2. 생성자 인자가 많을 떄는 Builder 패턴 적용을 고려하라

### 점층적 생성자 패턴

점층적 생성자 패턴은 필수 인자만 받는 생성자를 하나 정의하고, 선택적 인자를 받는 생성자들을 쌓아 올리듯 추가하는 방식이다. 이 패턴은 잘 동작하지만, 인자 수가 늘어나면 클라이언트 코드를 작성하기가 어려워지고, 무엇보다 읽기 어려운 코드가 되고 만다.

### 자바빈 패턴

인자 없는 생성자를 호출하여 객체부터 만든 다음, 설정 메서드들을 호출하여 필수 필드뿐 아니라 선택적 필드의 값들까지 채우는 방식이다. 하지만 1회의 함수 호출로 객체 생성을 끝낼 수 없으므로, 객체 일관석이 일시적으로 깨질 수 있다. 또한 자바빈 패턴으로는 변경 불가능 클래스를 만들 수 없다.

### 빌더 패턴

점층적 생성자 패턴의 안정성에 자바빈 패턴의 가독성을 결합한 패턴이다. 필요한 객체를 직접 생성하는 대신, 클라이언트는 먼저 필수 인자들을 생성자에 전부 전달하여 빌더 객체를 만들고, 빌더 객체에 정의된 설정 메서드들을 호출하여 선택적 인자들을 추가해 나간다. 마지막으로 아무런 인자 없이 build 메서드를 호출하여 변경 불가능 객체를 만드는 방식이다.

### 장점

* 작성하기도 쉽고, 읽기 쉽다.
* 불변식을 적용할 수 있다.
* 여러 개의 ``vargars`` 인자를 받을 수 있다.
* 유연하다. 하나의 빌더 객체로 여러 객체를 만들 수 있다.
* 인자가 설정된 빌더는 훌륭한 추상적 팩터리이다.

### 단점

* 객체를 생성하려면 우선 빌더 객체를 생성해야 한다.
* 점층적 생성자 패턴보다 많은 코드를 요구하기 때문에 인자가 충분히 많은 상황에서 이용해야 한다.

### 요약

빌더 패턴은 인자가 많은 생성자나 정적 팩터리 메서드가 필요한 클래스를 설계할 때, 특히 대부분의 인자가 선택적 인자인 상황에 유용하다.

## 규칙 3. private 생성자나 enum 자료형은 싱글턴 패턴을 따르도록 설계하라

### 싱글턴

싱글턴은 객체를하나만 만들 수 있는 클래스이며, 보통 유이할 수밖에 없는 시스템 컴포넌트를 나타낸다.

클래스를 싱글턴으로 만들면 클라이언트를 테스트하기가 어려워질 수가 있는데, 싱글턴이 어떤 인터페이스를 구현하는 것이 아니면 가짜 구현으로 대체할 수 없기 때문이다.

### 구현 방법

#### JDK 1.5 이전

``private``로 선언하고, 싱글턴 객체는 정적 멤버를 통해 이용한다.

싱글턴 클래스를 직려화 가능 클래스로 만들려면 클래스 선언에 ``implements Serializable``을 추가하는 것으로는 부족하다. 싱글턴 특성을 유지하려면 모든 필드를 ``transient``로 선언하고 ``readResolve`` 메서드를 추가해야 한다.

* 정적 멤버는 ``final``로 선언한다.

```java
public class Elvis {
	public static final Elvis INSTANCE = new Elvis();
    private Elvis() {}
    
    public void leaveTheBuilding() {...}
}
```

``private`` 생성자는 ``public static final``필드인 ``Elvis.INSTANCE``를 초기화 할 때 한번만 호출된다. ``public``이나 ``protected``로 선언된 생성자가 없으므로, ``Elvis`` 객체는 일단 ``Elvis``클래스가 초기화되고 나면 하나만 존재하게 된다. 하지만 ``AccessibleObject.setAccessible`` 메서드의 도움을 받아 권한을 회득한 클라이언트는 리플렉션 기능을 통해 ``private`` 생성자를 호출할 수 있다.

* ``public``으로 선언된 정적 팩터리 메서드를 이용한다.

```java
public class Elvis {
	private static final Elvis INSTANCE = new Elvis();
    private Elvis() {}
    public static Elivs getInstance() {return INSTANCE;}
    
    public void leaveTheBuilding() {...}
}
```

```Elvis.getInstance``는 항상 같은 객체에 대한 참조를 반환한다. 이것 외의 ``Elvis 객체는 만들 수 없다. 하지만 앞서 말한 리플렉션 기능을 통한 공격은 여전히 가능하다.

최신 JVM은 정적 팩터리 메서드 호출을 거의 항상 인라인 처리해 버리기 때문에 이 방법이 성능이 더 좋을 것이라는 기대는 접는 것이 좋다.

* 팩터리 메서드를 사용하는 방법의 장점
	* API를 변경하지 않고도 싱글턴 패턴을 포기할 수 있다.
	* 제너릭 타입을 수용하기 쉽다.

#### JDK 1.5 이후

* 원소가 하나뿐인 ``enum`` 자료형을 정의한다.

```java
public enum Elvis {
	INSTANCE;
    
    public void leaveTheBuilding() {...}
}
```

``public`` 필드를 사용하는 구현법과 동등하고 간결하다. 그리고 직렬화가 자동으로 처리되며, 리플렉션을 통한 공격에도 안전하다.

## 규칙 4. 객체 생성을 막을 때는 private 생성자를 사용하라

정적 메서드나 필드만을 모은 유틸리티 클래스들은 객체를 만들 목적의 클래스가 아니지만, 생성자를 생략하면 컴파일러는 자동으로 인자 없는 ``public`` 기본 생성자를 만들어 버린다.

* ``private`` 생성자를 클래스에 넣어 객체 생성을 방지한다.

```java
public class UtilityClass {
	private UtilityClass() {
    	throw new AssertionError(); // 클래스 안에서 실수로 생성자를 호출하면 알려준다.
    }
}
```

명시적으로 생성된 생성자가 ``private``이므로 클래스 외부에서는 사용할 수 없으며, 호출 가능한 생성자가 상위 클래스에 없기 때문에 하위 클래스도 만들 수 없다.

## 규칙 5. 불필요한 객체는 만들지 말라

기능적으로 동일한 객체는 필요할 때마다 만드는 것보다 재사용하는 편이 낫다. 변경 불가능 객체는 언제나 재사용할 수 있다.

생성자와 정적 팩터리 메서드를 함께 제공하는 변경 불가능 클래스의 경우, 생성자 대신 정적 팩터리 메서드를 이용하면 불필요한 객체 생성을 피할 수 있다.

### 정적 초기화 블록

정적 초기화 블록을 사용하면 비효율적인 코드를 개선할 수 있다.

```java
static {
	Calendar gmtCal = Calendar.getInstance(TimeZone.getTimeZone("GMT"));
    gmtCal.set(1946, Calendar.JANUARY, 1, 0, 0, 0);
    BOOM_START = gmtCal.getTime();
    gmtCal.set(1965, Calendar.JANUARY, 1, 0, 0, 0);
    BOOM_END = gmtCal.getTime();
}

public boolean isBabyBoomer() {
	return birthDate.compareTo(BOOM_START) >= 0 && birthDate.compareTo(BOOM_END) < 0;
}
```

* 성능이 개선된다.
* 코드가 간결하고 명료해진다.

### 어댑터

어탭터는 실제 기능 수행은 후면 객체에 위임하며, 후면 객체에 대한 또 다른 인터페이스를 제공하는 객체이다. 후면 객체가 관리하는 것 이외의 정보는 따로 저장하지 않으므로 특정 객체에 대한 어댑터를 하나 이상 만들 필요는 없다.

### 자동 객체화

JDK 1.5부터 자동 객체화를 통해 자바의 기본 자료형과 그 객체 표현형을 섞어 사용할 수 있도록 해 준다. 자동 객체화 덕에 기본 자료형과 그 객체 표현형 사이의 차이가 희미해지긴 했지만, 성능 차이는 무시하기 어렵다.

```java
public static void main(String[] args) {
	Long sum = 0L;
    for (long i = 0; i < Integer.MAX_VALUE; i++) {
    	sum += 1;
    }
    System.out.println(sum);
}
```

sum은 long이 아니라 Long으로 선언되어 있는데, 그 덕에 2^31^개의 쓸데없는 객체가 만들어진다.

객체 표현형 대신 기본 자료형을 사용하고, 생각지도 못한 자동 객체화가 발생하지 않도록 유의하라.

### 객체 풀

객체 풀을 만들어 객체 생성을 피하는 기법은 객체 생성 비용이 극단적으로 높지 않다면 사용하지 않는 것이 좋다.

최신 JVM은 고도로 최적화된 쓰레기 수집기를 갖고 있어서, 가벼운 객체라면 객체 풀보다 월등한 성능을 보여준다.

### 방어적 복사

방어적 복사가 요구되는 상황에서 객체를 사용하는 데 드는 비용은 쓸데없이 같은 객체를 여러 벌 만드는 비용보다 훨씬 높다. 필요할 때 방어적 복사본을 만들지 못하면 골치 아픈 버그나 보안 결함이 생길 수 있다.

## 규칙 6. 유효기간 지난 객체 참조는 폐기하라

```java
public class Stack {
	private Object[] elements;
	private int size = 0;
	private static final int DEFAULT_INITIAL_CAPACITY = 16;

	public Stack() {
		elements = new Object[DEFAULT_INITIAL_CAPACITY];
	}

	public void push(Object e) {
		ensureCapacity();
		elements[size++] = e;
	}

	public Object pop() {
		if (size == 0)
			throw new EmptyStackException();
		return elements[--size];
	}

	private void ensureCapacity() {
		if (elements.length == size)
			elements = Arrays.copyOf(elements, 2 * size + 1);
	}
}
```

이 예제는 스택이 커졌다가 줄어들면서 제거한 객체들을 쓰레기 수집기가 처리하지 못해서 생기는 "메모리 누수" 문제가 있어 쓰레기 수집기가 해야할 일이 많아져서 성능이 저하되거나, 메모리 요구량이 증가할 것이다.

위 스택이 경우에 ``elements`` 뱅ㄹ에서 실제로 사용되는 부분을 제외한 나머지 영역에 보관된 참조들은 다시 이용되지 않을 참조인 만기 참조다.

실수로 객체 참조를 계속 유지하는 경우, 해당 객체만 쓰레기 수집에서 제외되는 것이 아니라 그 객체를 통해 참조되는 다른 객체들도 쓰레기 수집에서 제외된다.

쓸 일 없는 객체 참조는 무조건 ``null``로 만든다.

```java
public Object pop() {
    if (size == 0)
        throw new EmptyStackException();
    Object result = elements[--size];
    elements[size] = null; // 만기 참조 제거
    return result;
}
```

* 객체 참조를 ``null``처리하는 것은 규범이라기보단 예외적인 조치가 되어야 한다.
* 만기 참조를 제거하는 가장 좋은 방법은 해당 참조가 보관된 변수 유효범위를 벗어나게 두는 것이다.
* 캐시도 메모리 누수가 흔히 발생하는 장소다.
* 메모리 누수가 흔히 발견되는 또 한 곳은 리스너 등의 역호출자(callback)다.

## 규칙 7. 종료자 사용을 피하라

종료자는 예측 불가능하며, 대체로 위험하고, 일반적으로 불필요하다. 종료자를 사용하면 시스템 오류, 성능 문제, 이식성 문제가 발생할 수 있다.

* 자바에서는 더 이상 참조되지 않는 객체에 할당된 공간을 쓰레기 수집기가 알아서 반환하므로 프로그래머 입장에서 특별히 할 일이 없다.
* 종료자는 즉시 시행되리라는 보장이 전혀 없기 때문에 긴급한 작업을 종료자 안에서 처리하면 안된다.
* 종료자 실행시점은 쓰레기 수집기 알고리즘에 좌우되는데, 이 알고리즘은 JVM 구현마다 크게 다르다.
* 클래스에 종료자를 붙여 놓으면, 드문 일이지만 객체 메모리 반환이 지연될 수 있다.
* 자바 명세에 종료자가 반드시 실행되어야 한다는 문구가 없으므로, 속성이 보장되어야 하는 중요 상태 정보는 종료자로 갱신하면 안된다.
* 일반적으로는 무점검 예외가 발생하면 스레드는 종료되고 스택 추적 정보가 표시되지만, 종료자 안에서는 경고 문구조차 출력되지 않는다.
* 종료자를 사용하면 프로그램 성능이 심각하게 떨어진다.

파일이나 스레드처럼 명시적으로 반환하거나 삭제해야 하는 자원을 포함하는 객체의 클래스는 명시적인 종료 메서드를 하나 정의하고, 더 이상 필요하지 않는 객체라면 클라이언트가 해당 메서드를 호출하도록 한다. 이때 종료 여부를 객체 안에 보관해야 한다.

이런 명시적 종료 메서드는 보통 try-finally 문과 함께 쓰이는데 객체 종료를 보장하기 위해서이다.

### 종료자를 사용할 때

* 명시적 종료 메서드 호출을 잊을 경우에 대비하는 안정망(해당 자원 발견시 반드시 경고 메시지르 록로 남겨야 한다.)
* 네이트비 피어와 연결된 객체를 다룰 때

"종료자 연결"이 자동으로 이루어지지 않기 때문에, 만일 어떤 클래스가 종료자를 갖고 있고 하위 클래스가 해당 메서드를 재정의하는 경우, 하위 클래스의 종료자는 상위 클래스의 종료자를 명시적으로 호출해야 한다.

하위 클래스에서 상위 클래스 종료자를 재정의하면서 상위 클래스 종료자 호출을 잊으면, 상위 클래스 종료자는 절대로 호출되지 않는다. 이 문제를 방지하는 한가지 방법은, 종료되어야 하는 모든 객체마다 여벌의 객체를 하나 더 만드는 것이다.

### 요약

자원 반환에 대한 최종적 안정장치를 구현하거나, 그다지 중요하지 않은 네이티브 자원을 종료시키려는 것이 아니라면 종료자는 사용하지 말자.
