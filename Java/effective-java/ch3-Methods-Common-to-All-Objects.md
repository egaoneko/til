# 3장. 모든 객체의 공통 메서드

`Object`는 객체 생성이 가능한 클래스이긴 하지만 기본적으로는 계승해서 사용하도록 설계된 클래스이다. `Object`에 정의된 비-final 메서드에는 명시적인 일반 규약이 있다. 이 메서드들을 재정의하는 클래스는 그 일반 규약을 따라야 한다.

## 규칙 8. equals를 재정의할 때는 일반 규약을 따르라

### equlas 메서드를 재정의하지 않는 경우

* 각각의 개체가 고유하다.
* 클래스에 **논리적 동일성** 검사 방법이 있건 없건 상관없다.
* 상위 클래스에서 재정의한 `equals`가 하위 클래스에서 사용하기에도 적당하다.
* 글래스가 `private` 또는 `package-private`로 선언되었고, `equals` 메서드를 호출할 일이 없다.

### equals 메서드를 재정의하는 것이 바람직한 경우

* 객체 동일성이 아닌 논리적 동일성의 개념을 지원하는 클래스
* 상위의 클래스의 `equals`가 하위 클래스의 필요를 충족하지 못할 때
* 단순히 어던 값을 표현하는 값 클래스 (단, 개체 통제 기능을 사용해 최대 하나의 객체만 존재하도록 제한하는 클래스는 제외)

### 일반 규약

* 반사성(reflexive) : `null`이 아닌 참조 `x`가 있을 때, `x.equals(x)`는 `true`를 반환한다.
* 대칭성(symmetric) : `null`이 아닌 참조 `x`와 `y`가 있을 때, `x.equals(y)`는 `y.equals(x)`가 `true`일 때만 `true`를 반환한다.
* 추이성(transitive) : `null` 아닌 참조 `x`, `y`, `z`가 있을 때, `x.equals(y)`가 `true`이고, `y.equals(z)`가 `true`이면 `x.equals(z)`도 `true`이다.
* 일관성(consistent) : `null` 아닌 참조 `x`와 `y`가 있을 때, `equals`를 통해 비교되는 정보에 아무 변화가 없다면 `x.equals(y)` 호출 겨로가는 호출 횟수에 상관없이 항상 같아야 한다.
* `null` 아닌 참조 `x`에 대해서, `x.equals(null)`은 항상 `false`이다.

### 어려움

#### 문제

객체 생성가능 클래스를 계승하여 새로운 값 컴포넌트를 추가하면서 `equlas` 규약을 어기지 않을 방법은 없다.

#### 해결책

계승하는 대신 구성을 사용한다.

### 지침

* `==` 연산자를 사용하여 `equals`의 인자가 자기 자신인지 검사하라.
* `instanceof` 연산자를 사용하여 인자의 자료형이 정확한지 검사하라.
* `equals`의 인자를 정확한 자료형으로 변환하라
* **중요** 필드 각각이 인자로 주어진 객체의 해당 필드와 일치하는지 검사한다.
* `equals` 메서드 구현을 끝냈다면, 대칭성, 추이성, 일관성의 세 속성이 만족되는지 검토하라.
* `equals`를 구현할 때는 `hashCode`도 재정의하라.
* 너무 머리 쓰지 마라.
* `equals` 메서드의 인자 형을 `Object`에서 다른 것으로 바꾸지 마라.

## 규칙 9. equals를 재정의할 때는 반드시 hashCode도 재정의하라

`equals` 메서드를 재정의하는 클래스는 반드시 `hashCode` 메서드도 재정의 해야 한다. 그렇지 않으면 `Object.hashCode`의 일반 규약을 어기게 되므로, 해시 기반 컬렉션과 함께 사용하면 오동작하게 된다. 아래 규약 중, 두 번째 규약에 위반된다.

### 규약

* 응용프로그램 실행 중에 같은 객체의 `hashCode`를 여러 번 호출하는 경우, `equals`가 사용하는 정보들이 변경되지 않았다면, 언제나 동일한 정수가 반환되어야 한다.
* `equals` 메서드가 같다고 판정한 두 객체의 `hashCode`값은 같아야 한다.
* `equals` 메서드가 다르다고 판정한 두 객체의 `hashCode`값은 꼭 다를 필요는 없다.

### 주의점

* 이상적인 해시 함수는 서로 다른 객체들을 모든 가능한 해시 값에 균등하게 배분해야 한다.
* 중복 필드는 해시 코드 계산 과정에서 제외해도 된다.
* `equals` 계산에 쓰이지 않는 필드는 제외해야 한다.(규약2 위반)
* 성능을 개선하려고 객체의 중요 부분을 해시 코드 계산 과정에서 생략하면 안된다. (속도는 빠를지라도, 해시 값 품질이 저하되어 성능도 저하된다.)

## 규칙 10. toString은 항상 재정의하라

`toString`의 일반 규약을 보면, `toString`이 반환하는 문자열은 **"사람이 읽기 쉽도록 간략하지만 유용한 정보를 제공해야 한다"**고 되어있다. 또한 **"모든 하위 클래스는 이 메서드를 재정의함이 바람직하다."**라고 조언한다. `toString`을 잘 만들어 놓으면 클래스를 좀 더 쾌적하게 사용할 수 있다.

### 주의점

* 가능하다면 `toString` 메서드는 객체의 중요 정보를 전부 담아 반환해야 한다.
* `toString`이 반환하는 문자열의 형식을 문서에 명시하건 그렇지 않건 간에, 어떤 의도인지는 문서에 분명하게 남겨야 한다.
* 문자열의 형식을 문서에 명시하건 그렇지 않건 간에, `toString`이 반환하는 문자열에 포함되는 정보들은 전부 프로그래밍을 통해서 가져올 수 있도록 하라.

## 규칙 11. clone을 재정의할 때는 신중하라

`Clonealbe`은 어떤 객체가 복제를 허용한다는 사실을 알리는 데 쓰려고 고안된 믹스인 인터페이스다. 이 목적에 부합하지 못하는데, 이 인터페이스에는 `clone` 메서드가 없으며, `Object`의 `clone` 메서드는 `protected`로 선언되어 있는 문제가 있다. 리플렉션을 사용하지 않고는 `Cloneable`을 구현한 객체라 해도 `clone` 메서드를 호출할 방법이 없다. `Cloneable`은 상위 클래스의 `protected` 멤버가 어떻게 동작할지 규정하는 용도로 쓰이고 있다.

### 규약

* `x.clone() != x`는 `true`
* `x.clone().getClass() == x.getClass()`는 `true` (반드시 그래야 하는 것은 아님, 느슨한 규정)
* `x.clone().equals(x)`는 `true` (반드시 그래야 하는 것은 아님)
* 어떤 생성자도 호출되지 않는다.(심한 규정)

### 주의점

* 비-final 클래스에 `clone`을 재정의할 때는 반드시 `super.clone`을 호출해서 얻은 객체를 반환해야 한다.
* `Cloneable` 인터페이스를 구현하는 클래슨느 제대로 동작하는 `public clone` 메서드를 제공해야 한다.
* `clone` 메서드는 또 다른 형태의 생성자다. 원래 객체를 손상시키는 일이 없도록 해야 하고, 복사본의 불변식도 제대로 만족시켜야 한다.
* `clone`의 아키텍쳐는 변경 가능한 객체를 참조하는 `final`필드의 일반적 용법과 호환되지 않는다.
* 생성자와 마찬가지로, `clone` 메서드는 복사본의 비-final 메서드, 즉 재정의 가능 메서드를 복사 도주에 호출해서는 안된다.
* `Object`의 `clone` 메서드는 `CloneNotSupportedException`을 던지도록 선언되어 있으며, `clone`을 재정의할 떄는 이 선언을 생략할 수 있다. 또한 `public clone` 메서드는 사실 해당 선언을 반드시 생략해야 한다.
* 다중 스레드에 안전해야 하는 클래스를 `Cloneable`로 만들려면, `clone` 메서드에도 동기화 메커니즘을 적용해야 한다.

### 요약

`Cloneable` 인터페이스를 구현하는 클래스를 계승하는 경우가 아니라면, 객체를 복사할 대안을 제공하거나, 아예 복제 기능을 제공하지 않는 것이 낫다. (ex. 변경 불가능 클래스)

객체 복제를 지원하는 좋은 방법은, 복사 생성자나 복사 팩터리를 제공하는 것이다.

`Cloneable`을 계승하는 인터페이스는 만들지 말아야 하며, 계승 목적으로 설계하는 클래스는 `Clonealbe`을 구현하지 말아야 한다.

## 규칙 12. Comparable 구현을 고려하라

`Object`의 `equals` 메서드와 특성은 비슷하지만, 단순한 동치성 검사 이외에 순서 비교가 가능하며, 좀 더 일반적이다. `Comparable` 인터페이스를 구현하는 클래스의 객체들은 자연적 순서를 갖게 된다. `Comparable`을 구현한 클래스는 다양한 제네릭 알고리즘 및 `Comparable` 인터페이스를 이용하도록 작성된 컬렉션 구현체와도 전부 연동할 수 있다.

### 규약

본 메서드는 이 객체와 인자로 주어진 객체를 비교한다. 이 객체의 값이 인자로 주어진 객체보다 작으면 음수를, 같으면 0을, 크면 양수를 반환한다. 인자로 전달된 객체이 자료형이 이 객체와 비교 불가능한 자료형인 경우에 `ClassCastException` 예외를 던진다.

* `compareTo`를 구현할 때는 모든 `x`와 `y`에 대해 `sgn(x.compareTo(y)) == -sng(y.compareTo(x))`가 만족되도록 해야 한다.
* `compareTo`를 구현할 때는 추이성이 만족되도록 해야 한다.
* `x.compareTo(y) == 0`이면 `sgn(x.compareTo(z)) == sgn(y.compareTo(z))`의 관계가 모든 `z`에 대해 성립하도록 해야 한다.
* 강력히 추천하지만 절대적으로 요구되는 것은 아닌 조건 하나는 `(x.compareTo(y) == 0) == (x.equals(y))`이다.

### 주의점

* 반사성, 대칭성, 추이성을 만족해야 하므로 `compareTo` 규약을 만족하면서 클래스를 계승하여 새로운 값 컴포넌트를 추가할 방법은 없다. 따라서 계승하여 확장하는 대신 구성을 사용하여야 한다.
* `Comparable` 인터페이스가 자료형을 인자로 받는 제네릭 인터페이스이므로 `compareTo` 메서드의 인자 자료형은 컴파일 시간에 정적으로 결정된다.
* 클래스에 선언된 중요 필드가 여러 개인 경우, 필드 비교 순서가 중요하다. 가장 중요한 필드부터 시작해서 차례로 비교해야 한다.