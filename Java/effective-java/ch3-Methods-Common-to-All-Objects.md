# 3장. 모든 객체의 공통 메서드

`Object`는 객체 생성이 가능한 클래스이긴 하지만 기본적으로는 계승해서 사용하도록 설계된 클래스이다. `Object`에 정의된 비-final 메서드에는 명시적인 일반 규약이 있다. 이 메서드들을 재정의하는 클래스는 그 일반 규약을 따라야 한다.

## 규칙 8. equals를 재정의할 때는 일반 규약을 따르라

### equlas 메서드를 재정의하지 않는 경우

* 각각의 개체가 고유하다.
* 클래스에 **논리적 동일성** 검사 방법이 있건 없건 상관없다.
* 상위 클래스에서 재정의한 `equals`가 하위 클래스에서 사용하기에도 적당하다.
* 글래스가 `private` 또는 `package-private`로 선언되었고, `equals` 메서드를 호출할 일이 없다.

### equals 메서드를 재정의하는 것이 바람직한 경우

* 객체 동일성이 아닌 논리적 동일성의 개념을 지원하는 클래스
* 상위의 클래스의 `equals`가 하위 클래스의 필요를 충족하지 못할 때
* 단순히 어던 값을 표현하는 값 클래스 (단, 개체 통제 기능을 사용해 최대 하나의 객체만 존재하도록 제한하는 클래스는 제외)


### 일반 규약

* 반사성(reflexive) : `null`이 아닌 참조 `x`가 있을 때, `x.equals(x)`는 `true`를 반환한다.
* 대칭성(symmetric) : `null`이 아닌 참조 `x`와 `y`가 있을 때, `x.equals(y)`는 `y.equals(x)`가 `true`일 때만 `true`를 반환한다.
* 추이성(transitive) : `null` 아닌 참조 `x`, `y`, `z`가 있을 때, `x.equals(y)`가 `true`이고, `y.equals(z)`가 `true`이면 `x.equals(z)`도 `true`이다.
* 일관성(consistent) : `null` 아닌 참조 `x`와 `y`가 있을 때, `equals`를 통해 비교되는 정보에 아무 변화가 없다면 `x.equals(y)` 호출 겨로가는 호출 횟수에 상관없이 항상 같아야 한다.
* `null` 아닌 참조 `x`에 대해서, `x.equals(null)`은 항상 `false`이다.

### 어려움

#### 문제

객체 생성가능 클래스를 계승하여 새로운 값 컴포넌트를 추가하면서 `equlas` 규약을 어기지 않을 방법은 없다.

#### 해결책

계승하는 대신 구성을 사용한다.

